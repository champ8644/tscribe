### üìÑ src\core.ts
```ts
import { promises as fs } from "fs";
import path from "path";
import { glob } from "glob";
import archiver from "archiver";
import { createWriteStream } from "fs";
import { pathToFileURL } from "url";
import { TscribeOptions } from "./types";

export async function tscribe(opts: TscribeOptions): Promise<void> {
  const headingTpl =
    opts.heading ||
    (opts.format === "plain" ? "// --- {file} ---" : "### {file}");

  const transformFn = await loadTransformPlugin(opts.transform);

  const exts = opts.ext.split(",").map((e) => e.trim().toLowerCase());
  const pattern = `${path.resolve(opts.src)}/**/*.{${exts.join(",")}}`;
  const ignoreList = opts.ignore.split(",").map((p) => p.trim());
  const files = await glob(pattern, { ignore: ignoreList });

  const sorted = await applySort(files, opts.sort);

  if (opts.list) {
    console.log(sorted.join("\n"));
    return;
  }

  const sections = await Promise.all(
    sorted.map(async (f) => {
      let body = await fs.readFile(f, "utf8");
      if (transformFn) {
        body = await transformFn(body, f);
      }
      const title = headingTpl.replace(
        "{file}",
        path.relative(process.cwd(), f)
      );
      return `${title}\n\n${body}`;
    })
  );

  const fullOutput = sections.join("\n\n");

  if (opts.zip) {
    const stream = createWriteStream(path.resolve(opts.zip));
    const archive = archiver("zip", { zlib: { level: 9 } });
    archive.pipe(stream);
    archive.append(fullOutput, { name: "output.txt" });
    await archive.finalize();
    await new Promise((res) => stream.on("close", res));
    if (!opts.quiet) console.log(`üì¶ Zipped output to ${opts.zip}`);
  } else if (opts.out) {
    await fs.writeFile(opts.out, fullOutput, "utf8");
    if (!opts.quiet) console.log(`‚úÖ Written to ${opts.out}`);
  } else {
    process.stdout.write(fullOutput);
  }
}

async function loadTransformPlugin(pathOrEmpty?: string) {
  if (!pathOrEmpty) return undefined;
  const fileUrl = pathToFileURL(path.resolve(pathOrEmpty)).href;
  const mod = await import(fileUrl);
  return mod.default ?? mod.transform;
}

async function applySort(files: string[], mode: TscribeOptions["sort"]) {
  switch (mode) {
    case "alpha":
      return files.sort((a, b) => a.localeCompare(b));
    case "mtime": {
      const stats = await Promise.all(
        files.map(async (f) => ({
          file: f,
          mtime: (await fs.stat(f)).mtimeMs,
        }))
      );
      return stats.sort((a, b) => a.mtime - b.mtime).map((s) => s.file);
    }
    case "path":
    default:
      return files;
  }
}
```

### üìÑ src\index.ts
```ts
import { Command } from "commander";
import chokidar from "chokidar";
import { tscribe } from "./core";
import { loadConfig } from "./load-config"; // refactor if needed
import { TscribeOptions } from "./types";

const program = new Command();

program
  .name("tscribe")
  .description(
    "Concatenate TypeScript-family files with headings, ready for ChatGPT."
  )
  .option("-s, --src <directory>", "root folder to scan", ".")
  .option("-o, --out <file>", "output file (stdout if omitted)", "")
  .option("--zip <file>", "write output to a zip file instead")
  .option("-e, --ext <list>", "comma-separated extensions", "ts,tsx")
  .option(
    "--ignore <patterns>",
    "comma-separated ignore patterns",
    "node_modules,dist,.git"
  )
  .option("--heading <template>", "heading template", "")
  .option("--format <type>", "heading format: md or plain", "md")
  .option("--sort <mode>", "sort files: alpha, path, or mtime", "path")
  .option("--transform <file>", "path to a JS file with transform function")
  .option("--list", "print file list only")
  .option("--watch", "watch for file changes")
  .option("--verbose", "print debug output")
  .option("--quiet", "suppress console logs")
  .parse(process.argv);

const cliOpts = program.opts<TscribeOptions>();

(async () => {
  try {
    const config = await loadConfig();
    const opts = { ...config, ...cliOpts };

    const run = async () => {
      try {
        await tscribe(opts);
      } catch (err) {
        console.error("‚ùå Runtime error:", err);
        process.exit(1);
      }
    };

    if (opts.watch) {
      console.log("üëÄ Watching...");
      chokidar
        .watch(opts.src, {
          ignored: opts.ignore.split(","),
          ignoreInitial: false,
        })
        .on("all", run);
    } else {
      await run();
    }
  } catch (err) {
    console.error("‚ùå Startup error:", err);
    process.exit(2);
  }
})();
```

### üìÑ src\load-config.ts
```ts
import path from "path";
import fs from "fs";
import { pathToFileURL } from "url";

export async function loadConfig(): Promise<Record<string, any>> {
  const configNames = [
    "tscribe.config.js",
    "tscribe.config.cjs",
    "tscribe.config.json",
  ];

  for (const name of configNames) {
    const full = path.resolve(name);
    try {
      await fs.access(full);

      if (name.endsWith(".json") || name.endsWith(".cjs")) {
        return require(full);
      } else {
        const fileUrl = pathToFileURL(full).href;
        return (await import(fileUrl)).default ?? {};
      }
    } catch {
      continue;
    }
  }

  return {};
}
```

### üìÑ src\types.ts
```ts
export interface TscribeOptions {
  src: string;
  out?: string;
  zip?: string;
  ext: string;
  ignore: string;
  heading?: string;
  format: "md" | "plain";
  sort: "alpha" | "path" | "mtime";
  list?: boolean;
  watch?: boolean;
  transform?: string;
  quiet?: boolean;
  verbose?: boolean;
}
```
